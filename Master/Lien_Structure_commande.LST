C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/24/2018 19:09:44 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE LIEN_STRUCTURE_COMMANDE
OBJECT MODULE PLACED IN Lien_Structure_commande.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.exe Lien_Structure_commande.c LARGE BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <c8051f020.h>
   2          #include <string.h>
   3          #include <stdio.h>
   4          #include <intrins.h>
   5          
   6          #include "FO_M1_Structures_COMMANDES_INFORMATIONS_CentraleDeCommande.h"
   7          #include "Config_ADC.h"
   8          #include "Servomoteur_horizontal.h"
   9          #include "ultrason.h"
  10          #include "Fonctions_cote_serializer.h"
  11          #include "Declarations_GPIO.h"
  12          #include "Config_Globale.h"
  13          #include "Timers.h"
  14          #include "Config_SPI.h"
  15          #include "Transmission_SPI.h"
  16          #include "UART0_RingBuffer_lib.h"
  17          #include "ConfigUART1.h"
  18          #include "Lien_Structure_commande.h"
  19          #include "Detect_Obst.h"
  20          #include "Generation_son.h"
  21          #include "Mesure_courant.h"
  22          #include "Encodage_Pointeur_lum.h"
  23          
  24          #ifndef CFG_Globale
  25            #define CFG_Globale
  26            #include "CFG_Globale.h"
  27          #endif
  28          
  29          //------------------------------------------------------------------------------------
  30          // D�clarations des variables globales
  31          //------------------------------------------------------------------------------------
  32          
  33          char a;
  34          char i =0;
  35          char message_s[50] = {0};
  36          char mess[50] = {0};
  37          void tempo_emiss(void);
  38          struct COMMANDES_SERIALIZER commande_serializer;
  39          float courant_actuel;
  40          float dist_avant;
  41          float dist_arriere;
  42          char Angle_voulu,msg_Slave,angle;
  43          signed int Angle_atteint = 0;
  44          extern unsigned int courant;
  45          extern double energie;
  46          
  47          void routage(struct COMMANDES commande, enum Routage * type){
  48   1      
  49   1        if (commande.Etat_Servo==Servo_H){
  50   2          *type=Servo_Hor;
  51   2        }
  52   1        else  if (commande.Etat_Servo==Servo_V){
  53   2          *type=Servo_Vert;
  54   2        }
  55   1        else if (commande.Etat_Mouvement!=Mouvement_non){
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/24/2018 19:09:44 PAGE 2   

  56   2          *type=Deplacement;
  57   2        }
  58   1        else if (commande.A_Obst!=DCT_non){
  59   2          *type=Obstacle;
  60   2        }
  61   1        else if (commande.Etat_Energie==Mesure_I){
  62   2          *type=Courant;
  63   2        }
  64   1        else if (commande.Etat_Energie==Mesure_E){
  65   2          *type=Energie;
  66   2        }
  67   1        else if (commande.frequence!=0){
  68   2          *type=Gene_Son;
  69   2        }
  70   1        else if (commande.Etat_Lumiere == Allumer){
  71   2          *type=Pointeur_Lum;
  72   2        }
  73   1      }
  74          // verifier attention effectuer les d�claration avant toute execution de code.
  75          void fonctionRoutage(struct COMMANDES commande){
  76   1        enum Routage route = Initialisation;
  77   1        unsigned char commande_SPI = 0x00;
  78   1        unsigned char trame[2] = 0;
  79   1        unsigned char taille_trame = 1;
  80   1        //double alpha;
  81   1        int distance;
  82   1        char angle_ascii[3];
  83   1        char mess[50] = {0};
  84   1        char mess1[50] = {0}; // utilis� dans le cas du d�placement �l�mentaire
  85   1        char mess2[50] = {0}; // idem
  86   1        char mess3[50] = {0}; // idem
  87   1        int compteur = 0;
  88   1        char msg_Slave_ascii[256];
  89   1        struct INFORMATIONS info;
  90   1        char courant_ascii[4];
  91   1        char energie_ascii[4];
  92   1        extern char affichage [50];
  93   1        char string_s[1000] = {2};
  94   1        int cpt = 0;
  95   1        routage(commande,&route);
  96   1      
  97   1        switch (route){
  98   2      
  99   2      // OK
 100   2          case Servo_H:
 101   2            Angle_voulu=commande.Servo_Angle;
 102   2            Angle_atteint = CDE_Servo_H(Angle_voulu);
 103   2            serOutstring("\n\r AS H");
 104   2      
 105   2            memset(mess,0,strlen(mess));
 106   2            strcpy(mess,angle_ascii);
 107   2            strcat(mess,"\n\r>");
 108   2            serOutstring(mess);
 109   2            break;
 110   2      
 111   2      // OK
 112   2          case Servo_V:
 113   2            commande_SPI = 0xD3;
 114   2            trame[0]=commande.Servo_Angle;
 115   2            if (commande.Servo_Angle < 0){
 116   3              trame[1] = 0xAA; //Pour prévenir le Slave que l'angle qu'il va recevoir est négatif
 117   3              trame[0] =~ trame[0]; //On prend le complément pour ne pas envoyé un début ou une fin de trame dans
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/24/2018 19:09:44 PAGE 3   

             - la SPI
 118   3            }
 119   2            else{
 120   3              trame[1] = 0xBB;
 121   3            }
 122   2            taille_trame = 2;
 123   2            echange_trame(trame,taille_trame,commande_SPI);
 124   2            tempo_emiss();
 125   2            msg_Slave = trame_recue();
 126   2            tempo_emiss();
 127   2            sprintf(msg_Slave_ascii,"%f",msg_Slave);
 128   2            serOutstring("\n\r AS V");
 129   2            serOutstring("\n\r>");
 130   2            break;
 131   2            
 132   2      // OK
 133   2          case Deplacement:
 134   2            if (commande.Etat_Mouvement == Depl_Coord) {
 135   3              distance = ceil(pow(pow(commande.Coord_Y,2)+pow(commande.Coord_X,2),0.5)); // Pythagore
 136   3      
 137   3              // instruction pour faire avancer le robot de la distance "distance"
 138   3              commande.Coord_X = distance;
 139   3              commande_serializer = transcode_commande_to_serializer(commande);
 140   3              formate_serializer(commande_serializer, message_s);
 141   3              serOutstring1(message_s);
 142   3              serOutstring(message_s);
 143   3              i=0;
 144   3              a=0;
 145   3              do{
 146   4                a=serInchar1();
 147   4                if (a!=0x00){
 148   5                  mess[i]=a;
 149   5                  i=i+1;
 150   5                }
 151   4              }while(a!=0x3E);
 152   3              
 153   3            }
 154   2            else{
 155   3              commande_serializer = transcode_commande_to_serializer(commande);
 156   3              formate_serializer(commande_serializer, message_s);
 157   3              serOutstring1(message_s);
 158   3              serOutstring(message_s);
 159   3              i=0;
 160   3              a=0;
 161   3              do{
 162   4                a=serInchar1();
 163   4                if (a!=0x00){
 164   5                  mess[i]=a;
 165   5                  i=i+1;
 166   5                }
 167   4              }while(a!=0x3E);
 168   3            }
 169   2            mess[i] = '\0';
 170   2            serOutstring(mess);
 171   2            break;
 172   2      
 173   2      
 174   2      // OK
 175   2          case Obstacle:
 176   2            Detect_Obst(commande);
 177   2            break;
 178   2      
C51 COMPILER V9.51   LIEN_STRUCTURE_COMMANDE                                               05/24/2018 19:09:44 PAGE 4   

 179   2      // A TESTER
 180   2          case Courant:
 181   2            info.Mesure_Courant = courant;
 182   2            sprintf(courant_ascii,"%d", info.Mesure_Courant);
 183   2            serOutstring(courant_ascii);
 184   2            serOutstring("mA\n\r>");
 185   2            break;
 186   2          
 187   2      // A TESTER
 188   2          case Energie :
 189   2            info.Mesure_Energie = energie;
 190   2            sprintf(energie_ascii,"%d", info.Mesure_Energie);
 191   2            serOutstring(energie_ascii);
 192   2            serOutstring("J\n\r>");
 193   2            break;
 194   2          
 195   2      // OK
 196   2          case Gene_Son:
 197   2            son_sonore(commande);
 198   2            serOutstring("\n\r>");
 199   2            break;
 200   2          
 201   2      // OK
 202   2          case Pointeur_Lum:
 203   2            pointeur_lum(commande);
 204   2            serOutstring("\n\r>");
 205   2            break;
 206   2      
 207   2          default:
 208   2            strcpy(mess,"\n\r#\n\r>");
 209   2            serOutstring(mess);
 210   2            break;
 211   2      
 212   2        }
 213   1      }
 214          
 215          void tempo_emiss(void){
 216   1        unsigned int x = 0;
 217   1      
 218   1        for(x=0;x<65000;x++);
 219   1        for(x=0;x<65000;x++);
 220   1        for(x=0;x<65000;x++);
 221   1        for(x=0;x<65000;x++);
 222   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1519    ----
   CONSTANT SIZE    =   1246    ----
   XDATA SIZE       =    134    1583
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
